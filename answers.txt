1.2 Главное правило, не вызывайте виртуальные функции во время работы конструкторов и деструкторов, потому что такие вызовы никогда не дойдут до производных классов, расположенных в иерархии наследования ниже того, который сейчас конструируется или уничтожается.

1.3 Поля у класса по умолчанию приватные, а у структуры публичные.

1.4 По стандарту new бросает исключения (если они не отключены глобально), а значит потенциально медленнее. На практике вы вряд ли заметите разницу, использование malloc вместо new - классическая преждевременная оптимизация. В любом случае стандартный malloc - тоже обычно не самое быстрое решение (есть TCmalloc, например), а реальное падение производительности на выделении памяти обычно означает неудачную архитектуру. Кроме того, operator new можно переопределить глобально через тот же malloc или другим способом.

1.5 Применение delete без [] к указателю на массив освобождает только нулевой элемент, а оставшиеся создают утечку памяти.

1.6 Функция std::vector широко известна как динамический массив. Он автоматически управляет динамической памятью внутри и сохраняет элементы, хранящиеся рядом, подобно массиву в стиле C. Последняя функция позволяет получать доступ к элементам в постоянное время. С другой стороны, команда std::list реализует структуру данных, в которой элементы управляются как двусвязный список. std::list элементы которого хранят указатели на предыдущий и последующий элементы. Благодаря этому вставка и удаление элементов происходит быстро, достаточно изменить несколько ссылок, а не перемещать элементы, как это делает динамический массив. Но получить доступ к элементу списка по индексу нельзя, ведь связный список не содержит индексов и элементы могут быть расположены в разных местах памяти.

1.7 auto_ptr умный указатель имеющий статус deprecated в стандарте выше C++11. Данный класс предоставляется стандартной библиотекой STL С++ и предназначен для работы с объектами, которые обычно необходимо удалять явно (например, объекты, созданные динамически с помощью оператора new). Для создания объекта класса auto_ptr параметром конструктора должен быть указатель на объект, созданный динамически. Дальше c auto_ptr можно работать почти как с обычным указателем, который указывает на тот же динамический объект, на который указывал исходный указатель. 

1.8 В данном случае у QString происходит implicit sharing (https://doc.qt.io/qt-5/implicit-sharing.html). Обе переменные будут ссылаться на одни и теже данные, но как одна из переменных QString попробует эти данные изменить - произойдёт их копирование.

1.9 Так можно делать, произойдет копирование, потому что const char* это стандартный тип C++, он не входит в список классов определяемых implicit sharing.

1.10 Начиная с Qt 5.7 foreach макрос имеет статус deprecated. В коде неправильный каст вместо str.toUtf8().constData(); надо писать str.toStdString().c_str() чтобы было с кириллической кодировкой. А еще при выполнении изначального кода будет результат clist = (Коля, Коля, Коля), что неправильно, а все потому что происходит implicit sharing

1.11 Процесс — экземпляр программы во время выполнения, независимый объект, которому выделены системные ресурсы (например, процессорное время и память). Каждый процесс выполняется в отдельном адресном пространстве: один процесс не может получить доступ к переменным и структурам данных другого. Если процесс хочет получить доступ к чужим ресурсам, необходимо использовать межпроцессное взаимодействие.

Поток использует то же самое пространства стека, что и процесс, а множество потоков совместно используют данные своих состояний. Как правило, каждый поток может работать (читать и писать) с одной и той же областью памяти, в отличие от процессов, которые не могут просто так получить доступ к памяти другого процесса. У каждого потока есть собственные регистры и собственный стек, но другие потоки могут их использовать.

Поток — определенный способ выполнения процесса. Когда один поток изменяет ресурс процесса, это изменение сразу же становится видно другим потокам этого процесса.

При выполнении нескольких потоков они будут неизменно взаимодействовать друг с другом, чтобы синхронизировать свое выполнение. Существует несколько методов синхронизации потоков:

 - Блоки взаимного исключения (Mutex);
 - Переменные состояния;
 - Семафоры.
    
Термин thread-safe класс применимый к многопоточному программированию. Класс потокобезопасен, если он функционирует исправно при использовании его из нескольких потоков одновременно. В частности, он должен обеспечивать правильный доступ нескольких потоков к разделяемым данным. 

1.12 Cложность алгоритма — понятие в информатике и теории алгоритмов, обозначающее функцию зависимости объёма работы, которая выполняется некоторым алгоритмом, от размера входных данных. 

http://i.stack.imgur.com/zntFK.png

1.13 SELECT 'ФИО' FROM 'Родители' WHERE 'Id родителя' IN
         (SELECT 'Id родителя' FROM 'Дети' WHERE COUNT('Id родителя') < 2)

1.14 Результат будет 8
